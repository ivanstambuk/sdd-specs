# Profiled Specification for TurboSHAKE, KangarooTwelve (KT128/KT256) and HopMAC (RFC 9861–Aligned)

This document is a **profile** of RFC 9861 “KangarooTwelve and TurboSHAKE”.[RFC9861]

It is an operationally complete Markdown profile document, normatively anchored in RFC 9861 and FIPS 202, for interoperable implementations generated by AI/LLM tools of:

* TurboSHAKE128
* TurboSHAKE256
* KT128 and KT256 (KangarooTwelve family)
* HopMAC128 and HopMAC256

### Audience & Scope

This specification is written **primarily** for AI/LLM and code-generation agents and for reasoning about the behavior of the implementations they generate, but **conformance is defined only for implementations**, not for agents.

All normative requirements in this document apply to implementations of the primitives defined in this profile that claim conformance. Agents and other tooling are one possible implementation toolchain for producing such implementations; any agent-level workflows described in this document are advisory and non-normative.

Conformance is **behavioral**: any implementation, regardless of how it was developed (human-written, AI-generated, or mixed), MAY describe itself as “conformant to this profile” if and only if its observable behavior matches the canonical behavioral core defined in this profile (the `Constraints` schema, API Contract YAML blocks, Algorithm YAML blocks, and the Error Model / Context* blocks in Part I) and it passes the required test vectors and conformance checks in “Test Vectors & Conformance”. The Functional and Non-Functional Requirements (FR-xxx/NFR-xxx) tables form the **normative obligation index** over that behavioral core: each FR/NFR entry restates requirements that are defined by the ProfileSchema bundle and Error Model and is used when evaluating conformance, but no FR/NFR row may introduce new numeric bounds, error categories, algorithm steps, or state-machine rules beyond those canonical sources.

An implementation MAY additionally describe itself as “AI-generated profile-conformant” if its code was produced by an AI/LLM or code-generation agent that followed the LLM Implementation Contract defined in this document. This additional label is optional metadata and does not change the underlying behavioral conformance criteria.

Maintenance and editing model (informative).

Process-level guidance for agent workflows, repository maintenance, and CI for this profile is documented separately (see `docs/agents-and-maintenance.md`) and in the repo-level docs under `docs/`. That material is non-normative and does not affect the behavioral or conformance requirements defined in this profile.

Canonical artifacts and role of this document.

* The **ProfileSchema YAML bundle** is the canonical, machine-readable representation of this profile’s behavioral core. It may be embedded (as in this document’s YAML code blocks), exported to separate `*.yaml`/`*.json` files, or both, but it MUST always preserve the IDs and structure defined by `ProfileSchemaMeta` and `IdTypes`.
* The **Functional and Non-Functional Requirements (FR-xxx/NFR-xxx) tables** form the normative obligation index over that behavioral core. They enumerate the behavioral and cross-cutting requirements that implementations MUST satisfy for conformance, but each entry is a derived restatement of constraints, algorithms, and Error Model rules defined in the ProfileSchema bundle and MUST NOT introduce independent numeric bounds, error categories, algorithm steps, or state-machine rules beyond those canonical sources.
* This Markdown document acts as the human-oriented **index and commentary** over the ProfileSchema bundle and FR/NFR tables. It restates, organizes, and explains the ProfileSchema for agents and reviewers, but it is subordinate to the bundle and FR/NFR tables for behavioral facts: whenever prose appears to disagree with the ProfileSchema, Error Model YAML, or FR/NFR entries, those structured artifacts are authoritative.

An example of the bundle-level metadata, as materialized in `profile-core.yaml`, is:

```yaml
ProfileBundle:
  id: "TurboSHAKE-KT-KT256-HopMAC-RFC9861-profile"
  version: "1.0.0"
  schema_version: 1
  files:
    - profile-core.yaml
    - conformance.yaml
```

The profile:

* Clarifies and, where needed for interoperability, fixes a specific subset of underspecified or “MAY/SHOULD” aspects in RFC 9861 (see “What This Profile Changes vs RFC 9861” and the non-normative “Profile Bindings” section in Part I).
* Records each such choice explicitly as a “profile decision” with rationale in the non-normative commentary.
* Assumes availability of a correct Keccak-p[1600,12] permutation implementation consistent with FIPS 202 and the usage in RFC 9861.[RFC9861]
* Distinguishes **normative** and **non-normative** material by role:

  * **Canonical behavioral core (normative for behavior)**: the `Constraints` schema, all API Contract YAML blocks for KP/TurboSHAKE/KT/HopMAC and any context types, all Algorithm YAML blocks, and the Error Model / ContextLifetime / ContextIndependence YAML blocks in **Part I – Normative Profile**, together with the test-vector definitions and conformance criteria in “Test Vectors & Conformance”. These elements together define all observable behavior for the cryptographic primitives in this profile. Any divergence between these canonical sources is a specification bug.
  * **Obligation index (normative for conformance)**: the Functional and Non-Functional Requirements (FR-xxx/NFR-xxx) tables. These tables index the behavioral and cross-cutting requirements that implementations MUST satisfy, but each FR/NFR entry is a derived restatement of the ProfileSchema bundle and Error Model and MUST NOT introduce independent numeric bounds, error categories, algorithm steps, or state-machine rules beyond those canonical sources.
  * **Derived summaries and indices (informative)**: `SpecIndex`, `AgentCoreView`, `ExternalSpecs`, `ExternalTestSuites`, `ExternalTestVectors`, `ProfileSchemaMeta`, `ProfileSchemaInvariants`, `IdTypes`, `ImplementationChecklist`, PB1–PB8, and all narrative prose (other than Algorithm YAML itself). These elements MUST be treated as generated or mechanically derived from the canonical behavioral core and FR/NFR tables. They MAY summarize or index obligations but MUST NOT introduce new numeric bounds, error categories, algorithm steps, state-machine rules, or other behavioral requirements beyond those defined by the canonical core and obligation index.

HopMAC128 and HopMAC256 are **profile-defined named primitives**: they are built from the HopMAC construction recommended in RFC 9861 but RFC 9861 itself does not define these named instances or their concrete key/tag policies.

All normative behavior in **Part I** is defined with these profile decisions applied; **Part II** documents and explains those decisions for reviewers and tooling.

This profile **narrows and operationalizes** RFC 9861: it fixes underspecified or “MAY” behaviors (for example, parameter bounds, error semantics, streaming contracts, and HopMAC policies) while preserving the underlying TurboSHAKE/KT constructions and the RFC 9861 test vectors. Any apparent change to those core algorithms or vectors is unintended and MUST be treated as a defect in this profile rather than a deliberate fork.

---

### Reader’s Map (Non-Normative)

Different readers should approach this profile differently:

- **Implementers and reviewers (humans):**
  - Start with **“Scope & Goals”**, then read:
    - `Constraints` (parameter ranges and types),
    - API Contracts for KP, TurboSHAKE, KT, HopMAC,
    - Algorithm YAML for TurboSHAKE, KT128/KT256, HopMAC128/256,
    - **Error Model** and **Functional/Non-Functional Requirements** as coverage indices,
    - **Test Vectors & Conformance** for how behavior is validated.
  - Use `profile-core.yaml` (ProfileSchema bundle) and `conformance.yaml` (test-vector bundle) as the canonical machine-readable view for tools, linters, and CI.

- **AI/LLM and code-generation agents:**
  - Follow **“How an Agent Uses This Specification”** to ingest the ProfileSchema and derive implementations:
    - First parse the ProfileSchema bundle in `profile-core.yaml` and the conformance bundle in `conformance.yaml` as the canonical machine-readable model and test set for this profile,
    - Then, if desired, ingest any YAML excerpts in this document as views over those bundles and consult FR/NFR and “Test Vectors & Conformance” to understand coverage and testing obligations.

- **Spec authors and maintainers:**
  - Treat Part I as the behavioral core and indices.
  - Keep long-form rationale, editorial philosophy, and design history in the **non-normative design notes** (see `docs/`), not in Part I; when behavior changes, update the ProfileSchema bundle first, then regenerate or adjust the derived tables and narrative.

---

## How an Agent Uses This Specification (Informative)

Agents generating implementations from this profile should:

1. Parse the ProfileSchema bundle in `profile-core.yaml` and the conformance bundle in `conformance.yaml` as the **only canonical machine-readable sources** for types, constraints, API Contracts, algorithms, Error Model/Context* blocks, indices/metadata, ConformanceCriteria, and test vectors. Any disagreement between these bundles and this Markdown MUST be resolved in favor of the bundles.
2. Treat the YAML code blocks, FR/NFR tables, SpecIndex, AgentCoreView, and ImplementationChecklist in Part I as **derived indices and summaries** for coverage and navigation only, never as independent sources of new bounds, algorithms, or variants.
3. Use “Test Vectors & Conformance” together with `conformance.yaml` to assemble the required test suite and conformance checks.

For deeper rationale and suggested implementation order, agents can consult the non-normative design notes in `specs/protocols/profile-design-notes.md`.

---

## Version and Change Log (Non-Normative)

- Current version: `1.0.0` (2025-11-26)

### Versioning policy

This profile uses a semantic-style versioning scheme `MAJOR.MINOR.PATCH` for the specification itself. At a high level:

- Within a given **major** version (for example, `1.x.y`), the set of primitives (KP, TurboSHAKE128/256, TurboSHAKEContext, KT128/256, HopMAC128/256) and their core algorithms, Constraints, and RFC 9861 test-vector expectations are intended to remain stable; MINOR versions may tighten requirements (for example, by adding new FR/NFR entries or clarifying Constraints and conformance obligations) but will not deliberately change the underlying constructions.
- A bump in the **major** version (for example, from `1.x.y` to `2.0.0`) is reserved for changes that would alter core behavior or conformance expectations (for example, changing Constraints, adding or removing primitives, or revising required test-vector sets).

Conformance claims MUST always state the profile version they target (for example, “conformant to the TurboSHAKE/KT/HopMAC profile v1.0.0”); conformance is defined with respect to the FR/NFR tables, Constraints, algorithms, and ConformanceCriteria for that specific version.

### Changelog

_No recorded changes yet._


---

## Part I – Normative Profile

The sections from “Scope & Goals” through “Test Vectors & Conformance” form the normative profile that implementations MUST satisfy when claiming conformance to this specification. Unless explicitly labeled “Non-Normative”, all subsections in Part I are normative for implementation behavior and conformance evaluation; agents and other tooling consume this profile in order to produce or validate such implementations but are not themselves conformance targets.

Part I is structured as a **machine-readable profile schema plus narrative**:

* The **ProfileSchema** for this profile is defined canonically by the ProfileSchema bundle in `profile-core.yaml` (including `TypesAndNotation`, `HostMapping`, the `Constraints` schema, all API Contracts and algorithms, the Error Model/Context* blocks, `SpecIndex`, `ExternalSpecs`, `ExternalTestSuites`, `ExternalTestVectors`, `ProfileSchemaMeta`, `ProfileSchemaInvariants`, `ProfileSchemaInvariantsRole`, `IdTypes`, `ConformanceCriteria`, and `ImplementationChecklist`). Part I of this document restates portions of that bundle for readers and agents, but those restatements are views over the bundle: whenever this Markdown disagrees with the ProfileSchema bundle, the bundle is authoritative.
* The surrounding prose, tables, and examples form the **narrative layer**, explaining and motivating the schema. Narrative text MUST NOT be interpreted to weaken or contradict the ProfileSchema or the FR/NFR tables; any apparent conflict is a specification bug.

### Conventions

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” are to be interpreted as described in BCP 14 (RFC 2119 and RFC 8174) **only** when they appear in clauses that specify:

- constraints on parameters and types (the `Constraints` schema and `constraints_ref` fields),
- algorithm and API behavior (Algorithm and API Contract YAML, including Error Model/Context* blocks),
- host-mapping requirements (for example, ErrorCategories and HostMapping rules),
- runtime behavioral aspects in FR/NFR entries, and
- test and coverage obligations in ConformanceCriteria.

In Part II and in sections explicitly labeled “Non-Normative”, these words are descriptive guidance only and do not introduce new requirements.

When these key words are used for primitives, algorithms, parameters, errors, FR/NFR entries, or ConformanceCriteria in Part I, they express requirements on the **runtime behavior of the generated implementation and on the associated test coverage**. When similar language appears in sections that discuss agent workflows, authoring processes, or editorial guidance (for example, suggested reading order or maintenance advice), it is descriptive and advisory only and does not introduce additional normative requirements beyond the behavioral core and conformance criteria.

In this document:

* “agent” means an AI/LLM or code-generation system that consumes this profile and emits code and tests from it.
* “implementation” and “implementation that claims conformance” refer to any cryptographic library or component that implements the primitives defined in this profile and satisfies all applicable FR/NFR requirements, regardless of whether its code was written by humans, generated by an agent, or produced by a mixed process.

Process note: this profile is written primarily for agents as its direct readers. Human-authored implementations are not required to follow any agent-level workflow described in this document; they MAY still claim conformance if their observable behavior matches this profile’s requirements and they pass the specified conformance tests.

This document is not intended as a human-facing cryptographic standard; it is a machine-focused profile whose only direct consumers at authoring time are agents and tools.

### What This Profile Changes vs RFC 9861 (Non-Normative)

This profile refines and tightens RFC 9861 in several focused ways:

- Fixes numeric bounds and error semantics for `D`, `L`, `|M|`, `|C|`, and `length_encode(x)` via the `Constraints` schema and Error Model (PB1–PB3).
- Defines a canonical TurboSHAKE streaming/context API (`TurboSHAKEContext`) with a precise `INIT → ABSORBING → SQUEEZING` state machine, while keeping streaming support optional (PB4).
- Standardizes HopMAC128/256 as named primitives with minimum tag lengths and explicit key-length documentation requirements on top of RFC 9861’s HopMAC construction (PB6).
- Tightens guidance for handling reserved TurboSHAKE `D` values when TurboSHAKE and KT coexist, recommending a library-level guard (PB1/PB7) while keeping the full RFC 9861 domain available and avoiding spec-level “expert modes”.
- Makes the Keccak-p[1600,12] bit/byte layout and round constants fully precise by normatively tying them to FIPS 202 and RFC 9861 (PB8).
- Introduces a machine-readable ProfileSchema (Constraints, API Contracts, algorithms, and ConformanceCriteria) and an explicit Error Model, together with FR/NFR tables as the obligation index, to drive tooling and conformance tests.

### What This Profile Deliberately Does Not Fix (Non-Normative)

This profile deliberately does **not** attempt to:

- Standardize protocol-level choices such as how `C` is structured, how many independent TurboSHAKE/KangarooTwelve domain bytes a protocol uses, or how `L` is chosen for a given application.
- Constrain key-management, key-derivation, or system-wide security goals that sit above TurboSHAKE/KT/HopMAC.
- Override host-environment limits on maximum message size, output length, memory usage, or threading models, beyond the combination of this profile’s guaranteed 64‑bit support for lengths and counters (up to at least `2^64 − 1` bytes for all profile-mandated lengths) and any stricter limits advertised by a given implementation; behavior beyond those limits is out of scope for this profile and not covered by its conformance guarantees.
- Redefine or extend RFC 9861’s security claims; it only restates them (for example, in “Security Levels & Output Length Guidance”) in a machine-friendly form.
- Define or bless HopMAC-style constructions with tag lengths below the profile minima in `Constraints.HopMAC.L_HopMAC128` and `Constraints.HopMAC.L_HopMAC256` (for example, 96-bit tags for HopMAC128 or 128-bit tags for HopMAC256). Protocols that require such shorter tags MAY use KT/TurboSHAKE directly or define their own MAC constructions, but such variants are outside the scope of this profile and MUST NOT be described as HopMAC128/256 conformant to it.

Design intent note: this profile is **intentionally opinionated** wherever RFC 9861 leaves cryptographic latitude. All “crypto knobs” that matter for interoperability and security (parameter domains and bounds, domain-separation values, tree layout, error semantics, HopMAC policies, etc.) are fixed here so that agents can implement mechanically without asking any external party to choose between alternatives.

### Normative precedence (behavioral conflicts)

This profile is written so that all observable behavior and conformance facts come from a **single canonical core**:

1. Behavioral core: the ProfileSchema bundle in `profile-core.yaml`, including the `Constraints` schema, API Contract and Algorithm YAML, Error Model/Context* blocks, FR/NFR tables, and `ConformanceCriteria`.
2. Test core: the conformance bundle in `conformance.yaml` together with the external RFC 9861 and FIPS 202 references it points to.

Markdown in this document (including algorithm prose, FR/NFR tables, and other narrative text) is a **view over that core**:

- YAML snippets, tables, and prose in `profile-spec.md` restate and organize the canonical ProfileSchema and conformance bundles for humans and agents.
- Whenever this Markdown appears to disagree with the ProfileSchema or conformance bundles, the bundles are authoritative and the Markdown must be corrected; prose is explanatory, not a competing source of behavior.

In particular:

- Parameter ranges, defaults, and error categories for `M`, `C`, `D`, `L`, `Key`, and streaming `len` are taken from the `Constraints` schema (and any `constraints_ref` / `default` usages in API Contracts and algorithms); FR/NFR text and commentary may paraphrase those bounds but must not change them.
- Function signatures, control flow, state machines, and allowed phases come from the relevant API Contract and Algorithm YAML; any table or prose that seems to alter those rules is a specification bug.
- Cross-cutting and non-functional properties (determinism, side-channel guidance, context independence, required coverage, documentation obligations) are defined by the NFR table together with the Error Model and Context* blocks.
- The FR/NFR tables serve as the obligation index (“what must be implemented and tested”) over the behavioral core and must reference only existing schema IDs and sections; they cannot introduce new numeric bounds, algorithms, or error categories.

Narrative prose in Part I and free-text fields in YAML (`description`, `notes`, etc.) are always subordinate to the canonical core. Consumers of this profile (including implementations and conformance tooling) must not derive new behavioral requirements solely from narrative text; every behavior that must be enforced at runtime must appear in the ProfileSchema bundle (Constraints, API/Algorithm definitions, FR/NFR, Error Model) or in the conformance bundle.

**LLM reading order (informative guidance for agents).**

* A typical agent workflow is to first parse the ProfileSchema bundle in `profile-core.yaml` and the conformance bundle in `conformance.yaml`, so that the agent has the full machine-readable view of types, parameters, API Contracts, algorithms, constraints, Error Model/Context* blocks, indices/metadata (including `SpecIndex`, `ExternalSpecs`, `ExternalTestSuites`, `ExternalTestVectors`, and `ProfileSchemaInvariants`), and ConformanceCriteria.
* After that, agents are encouraged to read the remaining prose in Part I and the FR/NFR tables, then consult Part II only for rationale and usage guidance. Where narrative text or free-text fields appear to disagree with those bundles, agents should treat the narrative as commentary and prefer the canonical bundles; such disagreements indicate a specification bug that should be corrected by updating the narrative.
* The canonical machine-readable definitions of `SpecIndex`, `ExternalSpecs`, `ExternalTestSuites`, and `ExternalTestVectors` live in the ProfileSchema and conformance bundles (`profile-core.yaml` and `conformance.yaml`); this document intentionally does not duplicate their YAML. Tools and CI systems that need structured indexes or test-vector metadata MUST consume those bundle definitions.

ProfileSchemaMeta, ProfileSchemaInvariants, ProfileSchemaInvariantsRole, and IdTypes are defined canonically in the ProfileSchema bundle in `profile-core.yaml`. In summary:

* `ProfileSchemaMeta` distinguishes behavioral fields (for example, `id`, `description`, `applies_to`, `type`, `min`, `max`, `error_category`, `inputs`, `output`) from metadata/indexing fields (for example, `fr`, `max_expr`, `notes`, `section`, `references`), so that tools can safely treat only behavioral fields as sources of runtime requirements.
* `ProfileSchemaInvariants` describe structural consistency properties of the ProfileSchema itself (for example, unique primitive/helper names in `SpecIndex`, valid scopes in `ExternalTestSuites`, uniqueness of canonical IDs, and well-formed FR/NFR references). They are evaluated over ProfileSchema artifacts, not over cryptographic implementations.
* `ProfileSchemaInvariantsRole` states that these invariants are normative for spec maintainers and for systems that claim **schema-level conformance** when they parse and distribute ProfileSchema artifacts (such as spec validators, CI pipelines, or canonical repositories). Any such system MUST evaluate the invariants at least once per ProfileSchema artifact and MUST treat a failing invariant as a defect in the specification artifact, stopping or escalating instead of silently proceeding with code generation or conformance claims. Library implementations that only claim **behavioral profile conformance** are not required to re-run the invariants themselves; they MAY rely on a ProfileSchema artifact that has already passed the invariants (for example, an official release or CI-validated copy), though library authors SHOULD prefer consuming such validated artifacts.
* `IdTypes` capture simple patterns for FR/NFR identifiers and primitive names and are used by tools to validate IDs and references.

The canonical machine-readable definitions of `ProfileSchemaMeta`, `ProfileSchemaInvariants`, `ProfileSchemaInvariantsRole`, and `IdTypes` live in `profile-core.yaml`; this document summarizes their roles but does not duplicate their YAML.

### Scope & Goals

This specification defines:

* Two XOF families based on Keccak-p[1600,12]: TurboSHAKE128 and TurboSHAKE256.[RFC9861]
* Two tree-hash XOFs over TurboSHAKE: KT128 and KT256 (KangarooTwelve family).[RFC9861]
* A hash-then-MAC construction HopMAC128 / HopMAC256 built on KT128 / KT256.[RFC9861]

#### Relationship to RFC 9861 (Normative)

* TurboSHAKE128/256 and KT128/256 are taken directly from RFC 9861; this profile only tightens underspecified aspects such as parameter bounds, error semantics, streaming contracts, and test obligations.
* HopMAC128 and HopMAC256 are additional **profile-defined** named primitives layered on top of the HopMAC construction described in RFC 9861 Section 4: RFC 9861 recommends the construction but does not standardize these named instances or their concrete key/tag policies. This profile fixes explicit APIs, minimum tag lengths, documentation requirements for the ≤69-byte SCA property, and the requirement to ship local HopMAC test vectors.

Goals for this profile:

1. Make the algorithms mechanically implementable by AI/LLM agents in any language, so that such agents can generate implementations directly from this document; the profile is not intended as a manual implementation specification.
2. Be faithful to RFC 9861 where it is precise, and *explicitly close* all important degrees of freedom.
3. Default to conservative, non-surprising cryptographic practice (parameter ranges, error semantics, domain separation). In particular, this profile guarantees that all profile-mandated lengths and counters are supported for values at least up to `2^64 − 1` bytes; RFC 9861’s larger conceptual domains (for example, the `0 ≤ x < 256^255` domain for `length_encode(x)`) MAY be implemented by libraries as extensions, but any behavior beyond the 64‑bit ranges fixed in this profile is out of scope for its conformance guarantees and SHOULD NOT be relied on for protocol-level interoperability.
4. Eliminate cryptographic degrees of freedom for implementers: all choices of parameters, domains, bounds, tree layouts, error semantics, HopMAC policies, and similar details that RFC 9861 leaves underspecified are fixed in this profile so that agents do not need to ask any external party to make cryptographic design decisions.
5. Minimize non-essential prose and background: narrative text in this profile exists only where it (a) constrains or clarifies observable behavior for implementations, or (b) materially reduces the risk of misimplementation by agents (for example, by calling out known failure modes or foot-guns). Purely expository, historical, or human-oriented background that does not affect behavior or implementation planning is out of scope for this document and SHOULD be kept in separate design or security-analysis artifacts instead of in the profile itself.
6. Stay strictly host-language agnostic: this profile defines behavior only in terms of conceptual types, Constraints, algorithms, and error categories. It MUST NOT standardize language-specific API names, module/package layouts, class hierarchies, or function signatures, and MUST NOT embed per-language examples (for example, C, Java, Rust snippets). Language- or platform-specific integration guidance belongs in separate documents and is out of scope for this profile.

This profile therefore defines a **stricter conformance regime** than RFC 9861: any implementation that is conformant to this profile MUST also satisfy the core TurboSHAKE/KT algorithms and test vectors in RFC 9861, but the converse is not guaranteed. In particular, the profile makes some RFC 9861–conformant behaviors explicitly non-conformant for this profile (for example, accepting out-of-range or undocumented `D` values without error, using extremely short HopMAC tags, or treating length bounds as unbounded instead of respecting the ProfileSchema constraints (including the guaranteed 64‑bit support range and deterministic error semantics) in the `Constraints` schema). When KT128/KT256 are exposed alongside TurboSHAKE, this profile further requires that public TurboSHAKE APIs reject the reserved values `D ∈ {0x06,0x07,0x0B}` by default (see PB7 and FR-003); support for those `D` values is only required for RFC 9861 test-vector coverage and may be surfaced via clearly distinguished conformance/test interfaces, not via general-purpose public APIs.

These stricter behaviors are **intentional hard gates** for this profile, not optional add-ons. An implementation that chooses to permit any of the behaviors in the parenthetical examples above (for example, allowing `D ∈ {0x06,0x07,0x0B}` for TurboSHAKE by default when KT is present, or accepting HopMAC tags shorter than the profile minima) MAY still be fully conformant to RFC 9861, but it MUST NOT claim conformance to this profile.

**Delta classes vs RFC 9861 (Non-Normative).**  
Within PB1–PB8, this profile introduces two kinds of deltas compared to RFC 9861:

- **Tightening / safety deltas (interoperability-preserving).** PB1–PB5 and PB8 only narrow underspecified behavior (parameter bounds, error semantics, streaming state machines, permutation details, and test obligations) without changing the core TurboSHAKE/KT algorithms, test vectors, or public API shapes defined in RFC 9861.
- **Behavioral / policy deltas (API-surface-affecting).** PB6 (HopMAC tag/key policies and documentation duties for the ≤69-byte SCA property) and PB7 (reserved TurboSHAKE `D` handling when KT is present) deliberately add library-level policies that may cause conformant implementations of this profile to reject some parameter choices and protocol patterns that RFC 9861 would allow. These are trade-offs in favor of safety and clarity for AI-generated code; they are explicitly called out in the PB summary and are **non-optional** for implementations that claim conformance to this profile.

Quantitative security levels and recommended output-length guidelines from RFC 9861 Section 7 are summarized and made explicit for this profile in the (non-normative) “Security Levels & Output Length Guidance” section below; implementations and protocol designs MAY use that section as a convenient reference when choosing `L` for specific preimage, collision, or post-quantum security targets, but it does not introduce additional normative requirements beyond RFC 9861 and the Constraints schema.

### LLM Implementation Contract (Informative for Agents)

This specification is **AI-first** and optimized for mechanical consumption by LLM and code-generation agents. The enforceable behavior for cryptographic primitives is defined entirely by the canonical behavioral core (Constraints, API Contracts, Algorithm YAML, and Error Model/Context* blocks) and the Test Vectors & Conformance criteria. This section is informative guidance for agents that choose to implement this profile directly from the specification and summarizes a recommended way to use that core to generate implementations:

- Agents should treat the canonical behavioral core in **Part I – Normative Profile** (Constraints, API Contracts, Algorithm YAML, Error Model/Context* blocks) as the sole source of observable behavior, and avoid deriving new behavior from FR/NFR tables, SpecIndex, AgentCoreView, or narrative prose.
- For all interface parameter bounds and validation (`M`, `C`, `D`, `L`, keys, streaming `len`), agents should take numeric ranges and error categories exclusively from the `Constraints` schema and `constraints_ref` fields in API/Algorithm YAML. If any FR/NFR text or profile-binding commentary appears to disagree, they should follow the ProfileSchema and treat the other wording as a spec bug.
- For control flow, state machines, and allowed phases, agents should follow the relevant API/Algorithm YAML definitions (for example, TurboSHAKEContext, KT128/KT256, HopMAC128/256) together with the Error Model/Context* blocks; FR/NFR summaries and prose may describe these rules but are not independent sources of behavior.
- Agents should use the Functional and Non-Functional Requirements (FR/NFR) tables as the complete obligation index for what must be implemented and tested (coverage and cross-cutting properties), understanding that every FR/NFR entry restates obligations already defined by the canonical behavioral core and external standards (RFC 9861, FIPS 202) and does not introduce additional numeric ranges, reserved-value sets, or algorithm variants beyond those canonical sources.
- When parsing the ProfileSchema bundle (for example from `profile-core.yaml`), agents should use `ProfileSchemaMeta` and `ProfileSchemaInvariants` to distinguish behavioral fields (constraints, types, algorithms, error categories) from indexing/commentary fields, and avoid deriving new behavior from metadata-only keys.

The detailed rationale, philosophy, and suggested implementation order for LLM agents are captured in `docs/profile-design-notes.md` and are non-normative; agents may consult those notes for additional context but should not treat them as independent sources of behavioral requirements.

Agents and tools that encounter questions or suggestions about any of the topics above should treat them as out of scope for changes to this document. If a different primitive set, length model, or security target is required, it should be expressed as a separate profile or a new major version, not as modifications to this profile.

---

## Profile Bindings (Non-Normative)

This profile defines a small number of **profile bindings** PB1–PB8 that narrow RFC 9861’s latitude (for example, by fixing bounds, error semantics, streaming state machines, and HopMAC policies). Their normative behavior is already captured in the ProfileSchema bundle (Constraints, API Contracts, algorithms, Error Model) and the FR/NFR tables; the PB labels exist only as an index for discussion in design notes and external documents (see the non-normative design notes in `docs/profile-design-notes.md` for detailed rationale). Implementations and conformance tools MUST take all enforceable behavior from the ProfileSchema bundle, Error Model, FR/NFR tables, and the Test Vectors & Conformance sections, not from PB summaries.
    * Implement the permutation directly from FIPS 202, using the same θ, ρ, π, χ, ι sequence and bit ordering, but with `n_r = 12` and the correct 12 round constants as per RFC 9861.[RFC9861]

* Any “bit-order variation” that diverges from FIPS 202’s mapping between bytes and lanes is non-conformant, even if some test vectors happen to match.

**Rationale (PB8).**

1. **Lane/bit order is a known failure mode for SHA-3 implementations.**
   Many subtle bugs arise from misunderstanding how bytes map into 64-bit lanes in Keccak. The only safe approach is to require exact adherence to FIPS 202.

2. **Rewriting Keccak in every profile is error-prone.**
   Copying and paraphrasing the full permutation into this document would duplicate content that has already been thoroughly vetted by NIST. It aids neither clarity nor security.

3. **Allowing “equivalent” variants breaks composability.**
   Once you allow “any mapping that matches test vectors”, you incentivize implementations to be clever with endian tricks, which undermines the idea of Keccak as a common primitive across primitives (SHA-3, SHAKE, TurboSHAKE, K12, etc.).

---

## Data Model & Notation

## Security Levels & Output Length Guidance (Non-Normative)

This section summarizes the quantitative security guidelines from RFC 9861 Section 7 and related generic cryptographic reasoning. It does not change the underlying Keccak-based security claims; it restates them in a form suitable for choosing `L` in protocols and APIs and for relating those choices to common security-target terminology (including NIST PQ “Level 2 / Level 5” labels) at a high level.

### 1. TurboSHAKE128 and KT128 (Informative)

TurboSHAKE128 and KT128 target **128-bit security** as described in RFC 9861 §7.[RFC9861] For a given call with output length `L_bits = 8 · L` (where `L` is in bytes), that section and standard generic attack analyses imply:

- 128-bit (second) preimage security:  
  - If `L_bits ≥ 128` (i.e., `L ≥ 16` bytes), generic second-preimage attacks require ≈2^128 work.
- 128-bit preimage security against `T` targets:  
  - If `L_bits ≥ 128 + log₂(T)`, generic multi-target preimage attacks over `T` independent targets require ≈2^128 work.
- 128-bit collision security:  
  - If `L_bits ≥ 256` (i.e., `L ≥ 32` bytes), generic collision attacks require ≈2^128 work.
*Informative mapping to NIST PQ levels.* The “Level 2” label above is an informal indication that these parameters are typically associated with the kinds of generic security targets that NIST defines for post-quantum security level 2, not a formal claim of conformance to any specific NIST PQ standard; such interpretations may evolve as PQ guidance and cryptanalysis advance.

### 2. TurboSHAKE256 and KT256 (Informative)

TurboSHAKE256 and KT256 target **256-bit security** as described in RFC 9861 §7.[RFC9861] For `L_bits = 8 · L`:

- 256-bit (second) preimage security:  
  - If `L_bits ≥ 256` (i.e., `L ≥ 32` bytes), generic second-preimage attacks require ≈2^256 work.
- 256-bit preimage security against `T` targets:  
  - If `L_bits ≥ 256 + log₂(T)`, generic multi-target preimage attacks over `T` independent targets require ≈2^256 work.
- 256-bit collision security:  
  - If `L_bits ≥ 512` (i.e., `L ≥ 64` bytes), generic collision attacks require ≈2^256 work.
*Informative mapping to NIST PQ levels.* The “Level 5” label above is an informal indication that these parameters are typically associated with the kinds of generic security targets that NIST defines for post-quantum security level 5, not a formal claim of conformance to any specific NIST PQ standard; such interpretations may evolve as PQ guidance and cryptanalysis advance.

Implementations and specifications that choose `L` smaller than these thresholds for a claimed security level SHOULD explicitly document the weaker security level or security target they rely on (for example, “64-bit collision resistance only”) and SHOULD treat such parameter choices as outside the scope of this profile’s default security targets, even though the underlying constructions may still be sound for those parameters.

### 3. HopMAC Tag-Length Rationale (Normative on minima, Informative on mapping)

For a uniformly distributed tag of `L_bits` bits, a generic MAC forgery attempt has success probability on the order of 2^−L_bits per independent trial. To avoid undermining the security of the underlying KT128/KT256 constructions:

- `Constraints.HopMAC.L_HopMAC128.min = 16` bytes (128 bits) is chosen so that straightforward tag-forgery attacks do not reduce security below the 128-bit target of KT128/TurboSHAKE128.
- `Constraints.HopMAC.L_HopMAC256.min = 32` bytes (256 bits) is chosen so that straightforward tag-forgery attacks do not reduce security below the 256-bit target of KT256/TurboSHAKE256.

Protocols MAY choose HopMAC tags longer than these minima (for example, 32 or 64 bytes) to align more closely with the collision-security thresholds above. However, choosing HopMAC tag lengths **shorter** than these minima (for example, 96-bit tags for HopMAC128 or 128-bit tags for HopMAC256) is deliberately out of scope for this profile’s default security targets: such parameter choices effectively define different MAC variants with weaker forgery resistance and MUST NOT be described simply as “HopMAC128” or “HopMAC256” conformant to this profile. Protocols that require shorter tags SHOULD either:

* treat themselves as operating outside the scope of this profile, or
* use a clearly named variant (for example, “HopMAC128‑96” for a 96-bit variant derived from HopMAC128, or “HopMAC256‑128” for a 128-bit variant derived from HopMAC256) with explicitly documented, weaker security targets.

This profile does not standardize those variants or their security targets; it only reserves the naming pattern and insists that any use of such variants document the effective tag security level.

### 4. Parameter & Policy Summary (Non-Normative)

For quick reference, this section summarizes the key parameter ranges and policy choices for this profile, derived from the `Constraints` schema and related entries in the ProfileSchema bundle in `profile-core.yaml`. In case of any discrepancy, the ProfileSchema bundle is authoritative.

- **TurboSHAKE (one-shot and streaming)**  
  - Message length `|M|` (TurboSHAKE): `0 ≤ |M| ≤ 2^64 − 1` bytes (see `Constraints.TurboSHAKE.M_length`).  
  - Output length `L` (TurboSHAKE): `1 ≤ L ≤ 2^64 − 1` bytes (see `Constraints.TurboSHAKE.L`).  
  - Domain byte `D` (TurboSHAKE): integer in `1 ≤ D ≤ 127` (see `Constraints.TurboSHAKE.D`), with default `D = 0x1F`.  
  - Reserved TurboSHAKE `D` values when KT is also exposed: `D ∈ {0x06, 0x07, 0x0B}` MUST be rejected by public TurboSHAKE APIs that are intended for general use (see `Constraints.TurboSHAKE.D.reserved_when_kt_present` and FR‑003).  
  - Streaming `squeeze(len)` parameter: `0 ≤ len ≤ 2^64 − 1` bytes per call (see `Constraints.Streaming.squeeze_len`); the total `N_total` covered by the streaming FR is `0 ≤ N_total ≤ Constraints.TurboSHAKE.L.max`.

- **KangarooTwelve (KT128/KT256)**  
  - Message length `|M|` (KT): `0 ≤ |M| ≤ 2^64 − 1` bytes (see `Constraints.KangarooTwelve.M_length`).  
  - Customization length `|C|` (KT): `0 ≤ |C| ≤ 2^64 − 1` bytes (see `Constraints.KangarooTwelve.C_length`).  
  - `length_encode(x)` domain: `0 ≤ x ≤ 2^64 − 1` (see `Constraints.KangarooTwelve.length_encode_domain`); calls outside this range MUST fail with ParameterError.

- **HopMAC (HopMAC128/HopMAC256)**  
  - Key length `|Key|`: `1 ≤ |Key| ≤ 2^64 − 1` bytes (see `Constraints.HopMAC.Key_length`), with the single‑permutation SCA advantage applying only for `|Key| ≤ 69` bytes.  
  - Tag length `L` for HopMAC128: `16 ≤ L ≤ 2^64 − 1` bytes (see `Constraints.HopMAC.L_HopMAC128`).  
  - Tag length `L` for HopMAC256: `32 ≤ L ≤ 2^64 − 1` bytes (see `Constraints.HopMAC.L_HopMAC256`).  
  - Tags shorter than these minima (for example, 96‑bit tags for HopMAC128 or 128‑bit tags for HopMAC256) are treated as out‑of‑scope variants (e.g., “HopMAC128‑96”, “HopMAC256‑128”) with weaker security targets and are not standardized by this profile.

Types, notation, host-mapping rules, and interface preconditions are defined canonically in the `TypesAndNotation` and `HostMapping` sections of the ProfileSchema bundle in `profile-core.yaml`. This document refers to those definitions but does not duplicate their YAML.

The canonical machine-readable `Constraints` schema for this profile (covering TurboSHAKE, KangarooTwelve, HopMAC, and Streaming entries such as `Constraints.TurboSHAKE.M_length`, `Constraints.KangarooTwelve.length_encode_domain`, and `Constraints.Streaming.squeeze_len`) is defined in the ProfileSchema bundle in `profile-core.yaml`. This document intentionally does not duplicate that YAML. Consumers of this profile MUST obtain all numeric parameter ranges, default values, and error categories from the `Constraints` entries in `profile-core.yaml` (and from any `constraints_ref` usages in API/Algorithm definitions), treating any conflicting prose here as a specification bug.

---

## Host Environment Assumptions

This profile is language-agnostic but assumes a minimal set of host capabilities:

* Bytes are 8-bit octets, and the host can represent ordered byte strings and fixed-size byte arrays (for example, the 200-byte internal sponge state).
* The host can represent non-negative integers large enough to model 64-bit unsigned counters and lengths (either as native `UInt64` or via a larger integer type or bignum), and can implement modular arithmetic and comparisons on those values.
* The host can express, directly or indirectly, the distinction between successful results and failures carrying an observable `ErrorCategory` as defined in the Error Model (for example via exceptions, tagged unions, or error codes).

Environments that cannot meet these assumptions (for example, those without 8-bit bytes or any way to model 64-bit counters) are outside the scope of this profile.

---

## Terminology Mapping to RFC 9861

This table maps the symbols and names used in this profile to the terminology in RFC 9861.

| This spec symbol/name | RFC 9861 term/symbol                 | Notes                                                                                      |
|-----------------------|--------------------------------------|--------------------------------------------------------------------------------------------|
| TurboSHAKE128         | TurboSHAKE128                        | Same primitive and parameters.                                                             |
| TurboSHAKE256         | TurboSHAKE256                        | Same primitive and parameters.                                                             |
| KT128                 | KT128 / KangarooTwelve128           | 128-bit security KangarooTwelve instance.                                                  |
| KT256                 | KT256 / KangarooTwelve256           | 256-bit security KangarooTwelve instance.                                                  |
| HopMAC128             | HopMAC128                            | Same construction.                                                                         |
| HopMAC256             | HopMAC256                            | Same construction.                                                                         |
| `M`                   | Message                              | Input message byte string.                                                                 |
| `C`                   | Customization string                 | Optional customization string.                                                             |
| `D`                   | Domain-separation byte               | TurboSHAKE domain byte in `0x01..0x7F`.                                                    |
| `L`                   | Output length                        | Number of output bytes requested.                                                          |
| `ptn(n)`              | `ptn(n)`                             | Identical pattern generator used to build RFC 9861 test messages.                          |
| `length_encode(x)`    | `length_encode(x)`                   | Identical Sakura-style length encoding function.                                           |
| `S`                   | Base string                          | Concatenation `M || C || length_encode(|C|)` before chunking.                              |
| `S_i`                 | Chunk `i`                            | 8192-byte (or final shorter) chunk of `S`.                                                 |
| `n`                   | Number of chunks                     | Total count of chunks `S₀..S_{n−1}`.                                                       |
| `CV_i`                | Chaining values                      | Fixed-length TurboSHAKE outputs per secondary chunk.                                       |

---

### Local Glossary (Non-Normative)

This profile also uses a few local terms that are not defined directly in RFC 9861:

- **context** – a long-lived object representing the state of a streaming or incremental API (for example, `TurboSHAKEContext`); contexts carry internal sponge state, buffered input, a fixed domain byte `D`, and a phase indicator such as `INIT`, `ABSORBING`, or `SQUEEZING`.
- **streaming API** – an interface that exposes contextful operations (`init`, `absorb`, `finalize`, `squeeze`, `reset`) rather than a one-shot `F(M, …)` call; in this profile, `API.TurboSHAKEContext` is the canonical streaming API, while any additional contextful KT/HopMAC APIs are considered extensions.
- **profile binding (PB1–PB8)** – a named rationale item that explains how this profile narrows or refines a specific latitude in RFC 9861 (for example, bounds for `D`, `L`, or HopMAC policies). Profile bindings are non-normative commentary; the corresponding normative behavior is fully captured in the ProfileSchema bundle (Constraints, API Contracts, algorithms, Error Model, FR/NFR tables).
- **ProfileSchema bundle** – the machine-readable YAML bundle in `profile-core.yaml` that defines the behavioral core for this profile (Constraints, API Contracts, algorithms, Error Model, FR/NFR, conformance criteria, indices/metadata).
- **Conformance bundle** – the YAML bundle in `conformance.yaml` that defines the machine-readable index of RFC 9861 test-vector families and local HopMAC test vectors used by conformance tools.

## Error Model

This spec describes behavior in terms of a simple, language-agnostic result type:

The canonical machine-readable Error Model (`ErrorModel.ResultType`, `ErrorModel.ErrorCategory`, `ErrorModel.ErrorCategoryTags`, `ErrorModel.ResultSemantics`, `ErrorModel.ContextLifetime`, and `ErrorModel.ContextIndependence`, including illustrative `failure_examples`) is defined in the ProfileSchema bundle in `profile-core.yaml`. This document summarizes its intent below but does not duplicate that YAML.

These categories describe the **conceptual classification** of failures for the purposes of this profile and its conformance tests. Implementations MAY refine them into more detailed error codes or exception types, and SHOULD document how those codes map to the three categories above when such a mapping is practical. Every conformant implementation MUST provide at least one machine-readable mechanism (which MAY be a dedicated diagnostics or conformance interface rather than the primary public API) that allows a test harness to classify each FR/NFR-covered failure into `ParameterError`, `StateError`, or `InternalError`, so that conformance tools can make consistent observations.

The `ResultType` and the name `OkOrErr` used in API Contracts are **conceptual**, not prescriptive: implementations MAY represent success and failure using tagged unions, exceptions, error codes, or other host-language mechanisms, as long as callers (or the test harness) can reliably distinguish successful outcomes from parameter/state failures and the semantics above are preserved (including “no new bytes on Err(reason)” and deterministic behavior for all inputs that satisfy the interface preconditions).

*Non-normative examples.* Typical observation patterns include:

- In C-style APIs, returning an error code and/or out-parameter that encodes one of `{ \"parameter\", \"state\", \"internal\" }` for use by a conformance harness, even if the public API exposes only a single error type to ordinary callers.
- In exception-based languages (for example, Java, C#, many scripting languages), using distinct exception subclasses or error enums for parameter/validation failures, state-usage errors, and unexpected internal faults, together with a small helper or test-harness API that exposes the corresponding conceptual category for each failure.

Where the host environment supports observable reporting of unexpected internal failures, implementations SHOULD map such failures to InternalError. Platforms that handle such conditions solely via fail-stop behavior (for example, process abort) are outside the scope of this profile for those specific failure paths; those paths MUST NOT be relied upon by callers for normal control flow.

When this spec says that an operation “MUST fail with a deterministic error”, it means the conceptual result is `Err(reason)` instead of `Ok(output)` as defined above and is subject to NFR-001, NFR-003, and NFR-010.

---

## Keccak-p[1600,12] Primitive

Let `KP` denote Keccak-p[1600,12].

### State Representation

* `KP` operates on a 1600-bit state, viewed as a 5×5 array of 64-bit lanes.
* The byte-to-lane mapping, and the sequence of steps (θ, ρ, π, χ, ι) MUST be exactly as in FIPS 202’s Keccak-f[1600].

The only difference is the number of rounds (12 instead of 24) and the subset of round constants used, exactly as in RFC 9861.[RFC9861]

### API Contract

The canonical machine-readable API contract for `KP` (id `API.KP`) is defined in the ProfileSchema bundle in `profile-core.yaml`. It specifies a single permutation operation on a 1600-bit state (`BitString[1600]`), interpreted as a 5×5 array of 64-bit lanes exactly as in FIPS 202, with no error cases and deterministic, side-effect-free behavior. This document summarizes that contract in prose; agents and tools MUST treat the `API.KP` entry in `profile-core.yaml` as authoritative for types and constraints.

This profile does **not** restate the full Keccak-f[1600] permutation. Implementations MUST obtain the complete permutation specification (state layout, step definitions, and round constants) from FIPS 202 and implement Keccak-f[1600] exactly, then restrict it to 12 rounds as described here and in RFC 9861.

This primitive is assumed correct; all higher constructions depend on it.

---

## TurboSHAKE128 and TurboSHAKE256

### 1. API Contract (Normative)

The canonical machine-readable API contracts for TurboSHAKE128 and TurboSHAKE256 (ids `API.TurboSHAKE128` and `API.TurboSHAKE256`) are defined in the ProfileSchema bundle in `profile-core.yaml`. They expose one-shot XOF interfaces `TurboSHAKE128(M, D, L)` and `TurboSHAKE256(M, D, L)` whose parameter bounds and error categories are taken from `Constraints.TurboSHAKE.M_length`, `Constraints.TurboSHAKE.D`, and `Constraints.TurboSHAKE.L`. Any discrepancy between this narrative and the `API.TurboSHAKE128` / `API.TurboSHAKE256` entries in `profile-core.yaml` MUST be resolved in favor of the bundle definitions.

These interface and parameter constraints correspond to FR-002–FR-007.

### 2. XOF Prefix Property

TurboSHAKE is an extendable-output function:

* For fixed `M` and `D`, if `L₁ < L₂`, then
  `TurboSHAKE(M, D, L₁)` equals the first `L₁` bytes of `TurboSHAKE(M, D, L₂)`.[RFC9861]

Any deviation from this property is non-conformant.

### 3. One-Shot Algorithm (Normative)

The canonical machine-readable definition of the one-shot TurboSHAKE algorithm (id `ALG.TurboSHAKE.OneShot`) is in the ProfileSchema bundle in `profile-core.yaml`. The steps below are a narrative rendering of that algorithm.

Given `(M, D, L)`:

1. **Check parameters.**

   * Validate `M`, `D`, and `L` as specified in the TurboSHAKE API Contracts and FR-002–FR-005; on any violation, fail with a deterministic ParameterError and do not produce output.

2. **Form `M'`.**

   * `M' = M || byte(D)`.

3. **Apply TurboSHAKE padding.**

   * Let `r` be the rate (168 or 136).
   * Compute `k = (r − (|M'| mod r)) mod r`.
   * If `k > 0`, append `k` bytes `0x00` to `M'`.
   * Let `M_padded` be the resulting string.
   * XOR `0x80` into the last byte of `M_padded`.

4. **Initialize state.**

   * `S` = 200-byte array of zeros.

5. **Absorb.**

   * Split `M_padded` into `b` blocks `B₀, …, B_{b−1}` of length `r`.
   * For each `B_i` in order:

     * For `j = 0..r−1`: `S[j] ^= B_i[j]`.
     * Set `S = KP(S)`.

6. **Squeeze.**

   * Initialize `out = empty`.
   * While `|out| < L`:

     * Append first `r` bytes of `S` to `out`.
     * If `|out| ≥ L`, break.
     * Else, set `S = KP(S)` and continue.
   * Truncate `out` to length `L` and return it.

This is exactly the sponge construction with Keccak-p[1600,12], capacity c, rate r, domain byte D as specified in RFC 9861.[RFC9861]

### 4. Streaming / Incremental API (Normative, Optional)

The canonical machine-readable streaming/context API for TurboSHAKE (id `API.TurboSHAKEContext`) is defined in the ProfileSchema bundle in `profile-core.yaml`. It specifies the context state (`S`, `D`, `buffer`, `phase ∈ {INIT, ABSORBING, SQUEEZING}`) and methods `init`, `absorb`, `finalize`, `squeeze`, and `reset`, together with their allowed phases, parameter constraints, and error categories. The state-machine table and prose that follow summarize that contract; agents and tools MUST treat the `API.TurboSHAKEContext` entry in `profile-core.yaml` as authoritative for the structured definition.

The context state machine can also be summarized as:

| Current phase | Allowed methods                        | Next phase(s)                                      | Error on disallowed call |
|---------------|----------------------------------------|----------------------------------------------------|---------------------------|
| INIT          | `init`, `absorb`, `finalize`           | INIT (re-init), ABSORBING, or SQUEEZING           | StateError                |
| ABSORBING     | `init`, `absorb`, `finalize`           | INIT (after init), ABSORBING, or SQUEEZING        | StateError                |
| SQUEEZING     | `init`, `squeeze`, `reset`             | INIT (after init), SQUEEZING, or (after reset) INIT | StateError              |

Any call made in a disallowed phase (for example, `squeeze` before `finalize`) MUST return `Err(reason)` as per the Error Model instead of `Ok(output)`, and the observable error category for such failures MUST be `StateError`. Failures caused by invalid parameters (for example, `D` or `len` values that violate their respective entries in the `Constraints` schema) MUST use the `ParameterError` category.

The error-state behavior for contexts is summarized in the following table; it is normative and MUST be kept consistent with `ErrorModel.ContextLifetime` and the `API.TurboSHAKEContext` definition in the ProfileSchema bundle:

| Phase before call | Operation      | Error category       | Result / effect                                                                                       | Phase after call | Context usable afterwards? |
|-------------------|---------------|----------------------|--------------------------------------------------------------------------------------------------------|------------------|----------------------------|
| any               | any           | ParameterError       | Returns `Err(ParameterError)` and produces no bytes; context state (including `phase`) MUST NOT change.| unchanged        | YES                        |
| INIT/ABSORBING    | any disallowed op (per table above) | StateError | Returns `Err(StateError)` and produces no bytes; context state (including `phase`) MUST NOT change.    | unchanged        | YES                        |
| SQUEEZING         | any disallowed op (per table above) | StateError | Returns `Err(StateError)` and produces no bytes; context state (including `phase`) MUST NOT change.    | unchanged        | YES                        |
| any               | any           | InternalError        | Returns `Err(InternalError)` and produces no bytes; context becomes unusable under this profile.       | implementation-defined internal marker | NO (all subsequent calls MUST fail without producing bytes or changing observable state) |

After a context has produced an InternalError for any operation covered by this profile, it is unusable for further cryptographic operations under this profile: APIs built on this profile MUST either dispose such contexts or ensure that any subsequent method calls (including `init`) immediately fail without producing new bytes or changing observable state (see ErrorModel.ContextLifetime).

Providing this streaming API is OPTIONAL for conformance. However, on host platforms that support long-lived objects or contexts, implementations are strongly RECOMMENDED to implement this streaming API exactly as specified, since it is the canonical streaming contract for TurboSHAKE in this profile. When the streaming API is not implemented, FR-008 and NFR-005 do not apply.

*Non-normative note.* Implementations MAY expose additional streaming or incremental interfaces (for example, APIs that combine `finalize` and the first `squeeze` call, or that wrap `TurboSHAKEContext` in higher-level helpers). Such additional interfaces are outside the scope of this profile’s conformance model and MUST NOT be described as `TurboSHAKEContext`; they MUST NOT violate the one-shot TurboSHAKE semantics or the parameter and error constraints defined elsewhere in this profile.

---

## KangarooTwelve (KT128 and KT256)

KangarooTwelve is a tree-hash built on TurboSHAKE.[K12Draft]

### 1. API Contract (Normative)

The canonical machine-readable API contracts for KT128 and KT256 (ids `API.KT128` and `API.KT256`) are defined in the ProfileSchema bundle in `profile-core.yaml`. They expose XOF interfaces `KT128(M, C, L)` and `KT256(M, C, L)` whose parameter bounds and error categories are taken from `Constraints.KangarooTwelve.M_length`, `Constraints.KangarooTwelve.C_length`, `Constraints.TurboSHAKE.L`, and `Constraints.KangarooTwelve.length_encode_domain` (for uses of `length_encode`). Any discrepancy between this narrative and the `API.KT128` / `API.KT256` entries in `profile-core.yaml` MUST be resolved in favor of the bundle definitions.

These interface and parameter constraints correspond to FR-009–FR-014.

### 2. `length_encode(x)` Algorithm (Normative)

The canonical machine-readable definition of the `length_encode` algorithm (id `ALG.length_encode`) is in the ProfileSchema bundle in `profile-core.yaml`. The steps below are its narrative form.

`length_encode(x)` is defined for integers `x` whose values lie within the domain specified by `Constraints.KangarooTwelve.length_encode_domain`. In this profile, that constraint guarantees support for all `x` with `0 ≤ x ≤ 2^64 − 1`, while RFC 9861’s broader conceptual domain `0 ≤ x < 256^255` is treated as an optional extension.

1. If `x < Constraints.KangarooTwelve.length_encode_domain.min` **or** `x > Constraints.KangarooTwelve.length_encode_domain.max`, the operation MUST fail with a deterministic error (ParameterError). This profile does not define or rely on any behavior for inputs outside that domain; such behavior, if implemented, is outside its conformance guarantees and SHOULD NOT be used in protocols that claim conformance to this profile.
2. Let `S` be an empty byte string.
3. While `x > 0`:

   * Let `b = x mod 256`.
   * Prepend the byte `b` to `S`.
   * Set `x = x / 256` (integer division).
4. If `S` is empty (original `x` was 0), set `S = 0x00`.
5. Append one byte whose value is `|S|` to `S`.
6. Return `S`.[RFC9861]

*Non-normative note.* RFC 9861 phrases the precondition for `length_encode(x)` as `0 ≤ x < 256^255`. This profile guarantees correct behavior for all `x` in the 64‑bit range `0 ≤ x ≤ 2^64 − 1` (via `Constraints.KangarooTwelve.length_encode_domain`) for all uses of `length_encode(x)`. Implementations MAY choose to support inputs beyond that 64‑bit range in a manner consistent with RFC 9861, but such behavior is outside this profile’s conformance guarantees and SHOULD be treated as an implementation-specific extension, not as part of any protocol that claims conformance to this profile.

### 3. Node Types and Constants

KangarooTwelve uses:

* Chunk size: 8192 bytes.[K12Draft]
* TurboSHAKE domain D values:

  * `0x07` for SingleNode.
  * `0x06` for FinalNode.
  * `0x0B` for IntermediateNode.[RFC9861]
* Padding constants inside the tree:

  * `0x03 || 0x00^7` as a fixed 8-byte constant in FinalNode in multi-node case.
  * `0xFF 0xFF` as fixed trailer after `length_encode(n−1)`.

### 4. KT128 Algorithm (Normative)

The canonical machine-readable definition of the KT128 algorithm (id `ALG.KT128`) is in the ProfileSchema bundle in `profile-core.yaml`. The steps below are its narrative form.

Input `(M, C, L)`.

1. **Parameter checks.**

   * Validate `M`, `C`, and `L` as specified in the KT API Contracts and FR-009–FR-014; on any violation, fail with a deterministic ParameterError and do not produce output.

2. **Form base string S.**

   * Compute `encC = length_encode(lenC)`.
   * `S = M || C || encC`.[RFC9861]

3. **Chunking.**

   * Split `S` into chunks `S₀, …, S_{n−1}` of 8192 bytes, where:

     * `|S_i| = 8192` for `i = 0..n−2`,
     * `|S_{n−1}| ≤ 8192`,
     * `n ≥ 1`.

4. **If `n = 1` (single-node case).**

   * Let `FinalNode = S` (only node).
   * Return:

     * `KT128(M, C, L) = TurboSHAKE128(FinalNode, D = 0x07, L)`.

5. **If `n ≥ 2` (tree case).**

   1. For `i = 1..n−1` (secondary chunks), compute chaining values:

      * `CV_i = TurboSHAKE128(S_i, D = 0x0B, L = 32)`.

   2. Build `FinalNode`:

      * Start with `FinalNode = S₀`.
      * Append the 8-byte constant: `0x03 || 0x00^7`.
      * Append all CVs: `CV₁ || CV₂ || … || CV_{n−1}`.
      * Append `length_encode(n−1)`.
      * Append `0xFF 0xFF`.

   3. Return:

      * `KT128(M, C, L) = TurboSHAKE128(FinalNode, D = 0x06, L)`.

### 5. KT256 Algorithm (Normative)

The canonical machine-readable definition of the KT256 algorithm (id `ALG.KT256`) is in the ProfileSchema bundle in `profile-core.yaml`. It has the same structure as KT128, with the differences noted below.

KT256 is defined identically, except:

* All TurboSHAKE calls use TurboSHAKE256.
* CVs are 64 bytes long:

  * `CV_i = TurboSHAKE256(S_i, D = 0x0B, L = 64)`.

Everything else is identical.

---

## HopMAC128 and HopMAC256 (Profile-Defined)

HopMAC is a hash-then-MAC construction based on KT128 and KT256.[RFC9861] The named instances HopMAC128 and HopMAC256 are **profile-defined** in this specification: RFC 9861 describes the underlying construction as a recommended method but does not standardize these named primitives or fix concrete tag/key policies. This profile standardizes HopMAC128/256 as named primitives on top of that construction, with stricter minimum tag lengths, explicit key-length documentation requirements, and mandatory local test vectors compared to RFC 9861 itself.

### 1. API Contract (Normative)
The canonical machine-readable API contracts for HopMAC128 and HopMAC256 (ids `API.HopMAC128` and `API.HopMAC256`) are defined in the ProfileSchema bundle in `profile-core.yaml`. They expose MAC interfaces `HopMAC128(Key, M, C, L)` and `HopMAC256(Key, M, C, L)` whose parameter bounds and error categories are taken from `Constraints.HopMAC.Key_length`, `Constraints.HopMAC.L_HopMAC128`, `Constraints.HopMAC.L_HopMAC256`, `Constraints.KangarooTwelve.M_length`, and `Constraints.KangarooTwelve.C_length`. Any discrepancy between this narrative and the `API.HopMAC128` / `API.HopMAC256` entries in `profile-core.yaml` MUST be resolved in favor of the bundle definitions.

These interface and parameter constraints correspond to FR-015–FR-017 and FR-023.

### 2. Algorithms (Normative)

The canonical machine-readable definitions of the HopMAC algorithms (ids `ALG.HopMAC128` and `ALG.HopMAC256`) are in the ProfileSchema bundle in `profile-core.yaml`. The step-by-step descriptions below are narrative renderings of those algorithms.

* **HopMAC128**:

  1. `inner = KT128(M, C, 32)`.
  2. `tag = KT128(Key, inner, L)`.
  3. Return `tag`.

* **HopMAC256**:

  1. `inner = KT256(M, C, 64)`.
  2. `tag = KT256(Key, inner, L)`.
  3. Return `tag`.[RFC9861]

### 3. Security Notes (Non-Normative)

* The inner call is **keyless**, mitigating SCA concerns: only the outer call must be hardened against key leakage.[RFC9861]
* If the key length is ≤ 69 bytes, the outer call requires only one permutation execution, which is favorable for SCA protection. For longer keys, implementations SHOULD consider additional SCA mitigation, although the specific countermeasures are outside the scope of this profile.

**Normative documentation hook.**

Any documentation that describes HopMAC128/256 as conformant to this profile MUST describe the “single-permutation SCA advantage” and its scope: that advantage only applies to keys whose lengths satisfy the side-channel guidance in this section (in particular, keys that fit into a single permutation call as described in RFC 9861), and using longer keys remains functionally correct but loses that specific advantage. Residual side-channel risks for those cases SHOULD be documented consistent with the guidance in NFR-002.

*Non-normative note.* This profile defines HopMAC128/256 as one-shot interfaces only. Implementations MAY provide additional streaming or contextful HopMAC or KT APIs, but such extensions are outside the scope of this specification and MUST still respect the general Error Model, length bounds, and (if contextful) the independence requirements in NFR-005.

---

## Functional Requirements

All functional behavior is summarized in the following table. The FR entries form a **derived, normative obligation index** over the canonical behavioral core (the `Constraints` schema, API Contracts, algorithms, and Error Model in Part I): they describe **what** behavior and cross-cutting properties must be covered, and by which primitives and contexts, but they do not define independent behavior beyond that core. Any implementation whose observable behavior matches the canonical behavioral core will automatically satisfy all applicable FR entries.

The FR/NFR tables are intended to be generated or mechanically validated against the canonical behavioral core; they MUST never diverge from it, and in any case of conflict the core schema and algorithms are authoritative.

Traceability note: profile bindings PB1–PB8 in the non-normative commentary are conceptually aligned with the corresponding FR-xxx and NFR-xxx entries, but the `Normative reference(s)` column intentionally points only to canonical behavioral sources (the `Constraints` schema, API Contracts, algorithms, the Error Model, and external standards such as RFC 9861 and FIPS 202) in order to satisfy the ProfileSchemaInvariants. FR/NFR descriptions MUST be concise restatements that reference existing constraints and algorithms only by ID or section; they MUST NOT introduce independent numeric bounds, new sets of reserved values, new algorithm steps, or new state-machine rules beyond those canonical sources. For numeric parameter bounds and interface preconditions, they reference the canonical definitions in the `Constraints` schema and API Contract YAML and MUST NOT introduce independent, conflicting ranges. Any semantic drift between FR/NFR tables, interfaces, algorithms, and `Constraints` is a specification inconsistency that MUST be corrected by updating the derived tables to match the canonical behavioral core.

Maintenance note (for spec authors and tooling): FR/NFR tables SHOULD be treated as derived from the ProfileSchema and either regenerated or re-validated via tooling whenever core behavioral changes are made, rather than edited in isolation.

Agent usage note: to decide *what to implement and test* for any claimed primitive, an agent should:

1. Take all observable behavioral rules (types, bounds, control flow, error semantics, reserved-value sets) from the `Constraints` schema, API Contract YAML, Algorithm YAML, and Error Model in Part I.
2. Use the FR/NFR tables below solely as the complete obligation index over that behavior (what must be covered and documented), not as an independent source of additional numeric ranges, reserved-value sets, or algorithm variants beyond those defined in the canonical behavioral core.
3. Treat any other section (including PB1–PB8, ImplementationChecklist, and appendices) as explanatory or planning material only, and when those sections need to talk about bounds or reserved values, have them do so only by referencing the appropriate `Constraints` or Algorithm/API entries by name.

| ID      | Title                                                   | Applies to                                       | Description                                                                                                                                                                                                                                                                                                                                                                                       | Normative reference(s)                                      |
|---------|---------------------------------------------------------|--------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------|
| FR-001  | Keccak-p[1600,12] permutation                           | All primitives                                   | The core permutation `KP` MUST conform to the Keccak-p[1600, n_r = 12] definition given in this profile’s “Keccak-p[1600,12] Primitive” section and in FIPS 202’s Keccak-f[1600], restricted to 12 rounds. Any deviation from that definition (including alternative bit/byte ordering or lane layout) is non-conformant, even if some test vectors accidentally match.                             | API.KP; RFC9861; FIPS202 |
| FR-002  | TurboSHAKE one-shot interface                           | TurboSHAKE128, TurboSHAKE256                     | The implementation MUST expose one-shot XOF interfaces `TurboSHAKE128(M, D, L)` and `TurboSHAKE256(M, D, L)` where `M` is a byte string, `D` is a domain-separation byte, and `L` is the requested output length. If `D` is omitted, it MUST default as specified in the TurboSHAKE domain-byte constraint entry in the Constraints schema.                                                          | API.TurboSHAKE128; API.TurboSHAKE256; Constraints.TurboSHAKE.M_length; Constraints.TurboSHAKE.D; Constraints.TurboSHAKE.L; RFC9861 |
| FR-003  | TurboSHAKE domain byte validation and reservation       | TurboSHAKE128, TurboSHAKE256                     | For all TurboSHAKE calls, the domain byte `D` MUST obey the numeric bounds and reservation policy given by `Constraints.TurboSHAKE.D`. Violations of the numeric bounds MUST be treated as deterministic ParameterErrors with no output bytes produced. When KT128/KT256 are also exposed in the same library, all public TurboSHAKE APIs that are intended for general use MUST treat any values listed in `Constraints.TurboSHAKE.D.reserved_when_kt_present` as reserved and fail with a deterministic ParameterError; implementations MAY expose separate conformance- or diagnostics-oriented interfaces that accept those reserved values solely for the purpose of exercising RFC 9861 test vectors, but such interfaces MUST be clearly distinguished from the default public APIs and MUST NOT be used in protocols that claim conformance to this profile. | Constraints.TurboSHAKE.D; RFC9861 |
| FR-004  | TurboSHAKE output length bounds                         | TurboSHAKE128, TurboSHAKE256                     | TurboSHAKE MUST support all requested output lengths `L` in the profile’s guaranteed range `Constraints.TurboSHAKE.L.min ≤ L ≤ Constraints.TurboSHAKE.L.max`. Within that range, `L` MUST be treated as a hard precondition: requests that violate the declared bounds (for example, `L < min` or `L > max`) MUST fail with a deterministic ParameterError and MUST NOT be satisfied by truncation, wrapping, partial output, or silent clamping. This profile does not define behavior for `L` outside the declared range; any such behavior is outside its conformance guarantees and SHOULD NOT be relied on for protocol-level interoperability. | Constraints.TurboSHAKE.L; RFC9861 |
| FR-005  | TurboSHAKE message length bounds                        | TurboSHAKE128, TurboSHAKE256                     | TurboSHAKE MUST support message lengths `|M|` in the profile’s guaranteed range `Constraints.TurboSHAKE.M_length.min ≤ |M| ≤ Constraints.TurboSHAKE.M_length.max`. Within that range, message-length bounds are hard preconditions: implementations MUST NOT silently truncate, wrap, or partially process messages whose length falls inside the guaranteed range. Inputs with `|M| < Constraints.TurboSHAKE.M_length.min` or `|M| > Constraints.TurboSHAKE.M_length.max` MUST be rejected with a deterministic ParameterError; this profile does not define behavior for such inputs, and any library-specific handling is outside its conformance guarantees and SHOULD NOT be relied on for protocol-level interoperability. | Constraints.TurboSHAKE.M_length; RFC9861 |
| FR-006  | TurboSHAKE sponge algorithm and padding                 | TurboSHAKE128, TurboSHAKE256                     | The one-shot TurboSHAKE algorithm MUST be implemented exactly as specified in this profile’s “TurboSHAKE… One-Shot Algorithm” section. Any deviation in block size, state layout, padding, or use of KP is non-conformant, even if some test vectors accidentally match.                                                                                                          | ALG.TurboSHAKE.OneShot; API.TurboSHAKE128; API.TurboSHAKE256; API.KP; RFC9861 |
| FR-007  | TurboSHAKE XOF prefix property                          | TurboSHAKE128, TurboSHAKE256                     | For all `M`, `D` and `L₁ < L₂`, the implementation MUST ensure that `TurboSHAKE(M, D, L₁)` equals the first `L₁` bytes of `TurboSHAKE(M, D, L₂)`. Any streaming or chunked interface MUST be consistent with this one-shot XOF prefix property.                                                                                                                                                     | ALG.TurboSHAKE.OneShot; API.TurboSHAKE128; API.TurboSHAKE256; RFC9861 |
| FR-008  | TurboSHAKE streaming state machine and equivalence      | TurboSHAKE128, TurboSHAKE256                     | If a streaming API is provided, it MUST implement the three-phase state machine `{INIT → ABSORBING → SQUEEZING}` defined in this profile, with `init`, `absorb`, and `finalize` allowed in INIT/ABSORBING as specified by `API.TurboSHAKEContext` and `init`, `squeeze`, and `reset` allowed in SQUEEZING. Absorbing is never allowed after finalization. For all `M`, `D`, and `L`, the result of `init(D); absorb(M); finalize(); squeeze(L)` MUST equal `TurboSHAKE(M, D, L)`, and multiple `squeeze(len)` calls MUST collectively equal the first `N_total` bytes of the corresponding one-shot call with `L = N_total` for any `N_total` in the range `0 ≤ N_total ≤ Constraints.TurboSHAKE.L.max`. Let `N_total` be the sum of all `len` values passed to successful `squeeze(len)` calls on a given context. Any single call with `len` outside `Constraints.Streaming.squeeze_len` MUST fail with a deterministic ParameterError and MUST NOT produce any bytes. This profile does not define behavior for sequences of `squeeze` calls with `N_total > Constraints.TurboSHAKE.L.max`; any such behavior is outside its conformance guarantees and SHOULD NOT be relied on for protocol-level interoperability. | API.TurboSHAKEContext; Constraints.TurboSHAKE.M_length; Constraints.TurboSHAKE.D; Constraints.TurboSHAKE.L; Constraints.Streaming.squeeze_len; ErrorModel.ContextLifetime; ErrorModel.ContextIndependence; RFC9861 |
| FR-009  | `length_encode(x)` domain and algorithm                 | KT128, KT256                                     | The helper `length_encode(x)` MUST be implemented exactly as specified in this profile’s `length_encode(x)` Algorithm section, including its domain and error semantics. Any deviation from that algorithm, including changes to its domain or failure behavior, is non-conformant.                                                                                                         | ALG.length_encode; Constraints.KangarooTwelve.length_encode_domain; RFC9861 |
| FR-010  | Customization length and node-count encoding            | KT128, KT256                                     | All uses of `length_encode(x)` in KT128/KT256 MUST match the canonical KT algorithms in the ProfileSchema bundle: `length_encode(x)` is applied only to `|C|` (customization length) and `n − 1` (number of secondary chunks), and those calls MUST respect the `length_encode` domain and error behavior defined in the `length_encode(x)` Algorithm and Constraints schema.                                             | ALG.length_encode; Constraints.KangarooTwelve.length_encode_domain; API.KT128; API.KT256; RFC9861 |
| FR-011  | KangarooTwelve base string and chunking                 | KT128, KT256                                     | KT128/KT256 MUST construct the base string and perform chunking exactly as specified in this profile’s “KangarooTwelve – Node Types and Constants” section. Any alternative base-string construction or chunking scheme is non-conformant.                                                                                                            | API.KT128; API.KT256; ALG.KT128; ALG.KT256; Constraints.KangarooTwelve.M_length; Constraints.KangarooTwelve.C_length; RFC9861 |
| FR-012  | KT128 single-node case (`n = 1`)                        | KT128                                            | KT128’s single-node (`n = 1`) behavior MUST match the algorithm defined in this profile’s “KangarooTwelve – KT128 Algorithm” section; any change to how SingleNode is handled is non-conformant.                                                                                                                                                        | API.KT128; ALG.KT128; Constraints.KangarooTwelve.M_length; Constraints.KangarooTwelve.C_length; RFC9861 |
| FR-013  | KT128 tree case (`n ≥ 2`)                               | KT128                                            | KT128’s tree (`n ≥ 2`) behavior MUST match the algorithm defined in this profile’s “KangarooTwelve – KT128 Algorithm” section, including chaining-value computation, FinalNode construction, and D values; no alternative tree layout is conformant.                                                                                                  | API.KT128; ALG.KT128; Constraints.KangarooTwelve.M_length; Constraints.KangarooTwelve.C_length; Constraints.KangarooTwelve.length_encode_domain; RFC9861 |
| FR-014  | KT256 variant of KangarooTwelve                         | KT256                                            | KT256 MUST implement the algorithm defined in this profile’s “KangarooTwelve – KT256 Algorithm” section exactly, including its use of TurboSHAKE256 and chaining-value length. Any deviation from that algorithm is non-conformant.                                                                                                                     | API.KT256; ALG.KT256; Constraints.KangarooTwelve.M_length; Constraints.KangarooTwelve.C_length; Constraints.KangarooTwelve.length_encode_domain; RFC9861 |
| FR-015  | HopMAC128 construction                                  | HopMAC128                                        | HopMAC128 MUST be implemented exactly as `HopMAC128(Key, M, C, L) = KT128(Key, KT128(M, C, 32), L)` with `Key` a non-empty byte string, `M` the message, and `C` an optional customization string; tag and key length bounds are defined by the corresponding entries in `Constraints.HopMAC.*` and FR-017. Any deviation in construction (e.g., swapping inner/outer roles or mixing KT128/KT256) is non-conformant. | API.HopMAC128; ALG.HopMAC128; Constraints.HopMAC.Key_length; Constraints.HopMAC.L_HopMAC128; Constraints.KangarooTwelve.M_length; Constraints.KangarooTwelve.C_length; RFC9861 |
| FR-016  | HopMAC256 construction                                  | HopMAC256                                        | HopMAC256 MUST be implemented exactly as `HopMAC256(Key, M, C, L) = KT256(Key, KT256(M, C, 64), L)` with `Key` a non-empty byte string, `M` the message, and `C` an optional customization string; tag and key length bounds are defined by the corresponding entries in `Constraints.HopMAC.*` and FR-017. Any deviation in construction is non-conformant.                                  | API.HopMAC256; ALG.HopMAC256; Constraints.HopMAC.Key_length; Constraints.HopMAC.L_HopMAC256; Constraints.KangarooTwelve.M_length; Constraints.KangarooTwelve.C_length; RFC9861 |
| FR-017  | HopMAC tag length and key constraints                   | HopMAC128, HopMAC256                             | HopMAC tag and key lengths MUST obey the bounds defined in `Constraints.HopMAC.Key_length`, `Constraints.HopMAC.L_HopMAC128`, and `Constraints.HopMAC.L_HopMAC256`; any violation MUST be enforced as a hard precondition that fails with deterministic ParameterError. These minima encode this profile’s default security targets for HopMAC128/256. Operating with tag lengths below the configured minima is outside this profile’s default conformance model: such parameter choices MUST NOT be described as plain “HopMAC128” or “HopMAC256” conformant to this profile and, if they are used at all, they SHOULD be described as separate, explicitly named variants (for example, “HopMAC128‑96”) with clearly documented, weaker tag-security targets.                                                                                                                          | API.HopMAC128; API.HopMAC256; Constraints.HopMAC.Key_length; Constraints.HopMAC.L_HopMAC128; Constraints.HopMAC.L_HopMAC256; RFC9861 |
| FR-018  | Pattern `ptn(n)` definition                             | TurboSHAKE128, TurboSHAKE256, KT128, KT256       | The byte pattern generator `ptn(n)` used for RFC 9861 test vectors MUST match the definition in this profile’s “Test Vectors & Conformance – ptn(n) Definition” section and in RFC 9861 Section 5. Any alternative pattern is non-conformant.                                                                                                            | RFC9861 |
| FR-019  | TurboSHAKE128 test vectors                              | TurboSHAKE128                                    | For all TurboSHAKE128 test cases listed in RFC 9861 Section 5 (including empty-message cases, `ptn(17**k)` cases, and the various `FF…` and `D` combinations, including those with `D ∈ {0x06,0x07,0x0B}`), the implementation MUST be able to produce outputs exactly equal to the RFC 9861 reference values.                                      | API.TurboSHAKE128; ALG.TurboSHAKE.OneShot; RFC9861 |
| FR-020  | TurboSHAKE256 test vectors                              | TurboSHAKE256                                    | For all TurboSHAKE256 test cases listed in RFC 9861 Section 5 (including empty-message, `ptn(17**k)`, and `FF…`/`D` combinations, including those with `D ∈ {0x06,0x07,0x0B}`), the implementation MUST be able to reproduce the RFC 9861 reference outputs exactly.                                                     | API.TurboSHAKE256; ALG.TurboSHAKE.OneShot; RFC9861 |
| FR-021  | KT128 test vectors                                      | KT128                                            | For all KT128 test cases listed in RFC 9861 Section 5 (including empty M/C, `ptn(n)` for message and/or customization, large 8191/8192-byte patterns, and `FF…` customizations), the implementation MUST reproduce the KT128 reference outputs in RFC 9861 exactly.                                                                                                 | API.KT128; ALG.KT128; RFC9861 |
| FR-022  | KT256 test vectors                                      | KT256                                            | For all KT256 test cases listed in RFC 9861 Section 5 (including empty M/C, `ptn(n)` messages, and long-output and “last bytes” cases), the implementation MUST reproduce the KT256 reference outputs in RFC 9861 exactly.                                                                                                                               | API.KT256; ALG.KT256; RFC9861 |
| FR-023  | Local HopMAC test vectors                               | HopMAC128, HopMAC256                             | Implementations that claim HopMAC128/256 conformance SHOULD include automated tests for the canonical HopMAC128 and HopMAC256 local test vectors defined in this profile’s “Test Vectors & Conformance – Local HopMAC Test Vectors” section and SHOULD verify that the computed tags for those `(Key, M, C, L)` tuples exactly match the reference tags given there. Implementations MAY define and document additional local HopMAC test vectors, but such additional vectors are outside the scope of this profile’s conformance model. | API.HopMAC128; API.HopMAC256 |
| FR-024  | No partial outputs on error                             | All primitives                                   | For all primitives and operations in this profile (one-shot and streaming), whenever the conceptual result is `Err(reason)` (whether `ParameterError`, `StateError`, or `InternalError`), the operation MUST NOT append any new bytes to the caller’s logical output for that call, and previously returned outputs from earlier successful calls MUST remain unchanged.                           | ErrorModel.ResultSemantics |

## Non-Functional Requirements

Non-functional requirements capture cross-cutting properties (security, portability, and engineering discipline). A conformant implementation MUST satisfy all applicable NFRs in addition to the FRs above.

Some NFRs in this profile constrain **runtime behavior** (for example, constant-time handling, zeroization, cross-platform consistency), while others define **documentation and operational obligations** (for example, documenting stricter limits or residual side-channel risks). Both kinds of clauses are normative for agents: implementations MUST satisfy the behavioral parts at runtime and MUST generate the corresponding documentation where required.

| ID       | Title                                         | Applies to                                      | Description                                                                                                                                                                                                                                                                                                                                       | Normative reference(s)                            |
|----------|-----------------------------------------------|-------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|
| NFR-001  | Deterministic, side-effect-free primitives    | All primitives                                  | For fixed inputs, all primitives in this profile (TurboSHAKE128/256, KT128/256, HopMAC128/256) MUST be deterministic: repeated calls with identical inputs MUST produce identical outputs, independent of platform, compiler, or optimization level, and MUST NOT depend on hidden global mutable state or randomness.                             | API.KP; API.TurboSHAKE128; API.TurboSHAKE256; API.KT128; API.KT256; API.HopMAC128; API.HopMAC256; RFC9861 |
| NFR-002  | Constant-time handling of secret data         | All primitives (when processing secrets)        | Operations whose inputs include secret keys (e.g., HopMAC keys or any use of TurboSHAKE/KT with secret material) MUST implement MAC/tag comparison using a constant-time comparison routine or an equivalent side-channel-hardened primitive when such a facility exists in the target environment (for example, a documented constant-time comparison API or a widely used cryptographic library primitive). If no such facility exists, implementations MUST either provide their own constant-time comparison or clearly document that comparisons are not constant-time for the target/platform combination. Implementations SHOULD avoid key-dependent branches and memory access patterns in the outer HopMAC call’s main loop, and SHOULD minimize secret-dependent branches in other secret-processing code. A minimal non-negotiable requirement is that implementations MUST NOT implement MAC/tag comparisons on secret-dependent values using naive byte-wise equality functions that are documented or known to be non-constant-time (for example, a plain `memcmp`-style comparison); when hardened comparison primitives are available, they SHOULD be preferred and their use SHOULD be documented briefly (e.g., “tag comparisons use `<name>` in constant time”). Documentation requirement (informative): generated documentation should briefly describe residual side-channel risks and any lack of constant-time facilities, using a short, factual statement rather than extensive prose. | Constraints.HopMAC.Key_length; Constraints.HopMAC.L_HopMAC128; Constraints.HopMAC.L_HopMAC256; API.HopMAC128; API.HopMAC256; RFC9861 |
| NFR-003  | Deterministic error semantics                 | All primitives                                  | All parameter validation failures (invalid `D`, `L`, `|M|`, `|C|`, or `x` to `length_encode`) MUST result in deterministic, documented errors and MUST NOT return partial or ambiguous output. Such failures MUST be reported using the `ParameterError` category defined in the Error Model, and implementations MUST NOT rely on undefined behavior in the host language to signal errors. | ErrorModel.ResultType; ErrorModel.ErrorCategory; ErrorModel.ResultSemantics; RFC9861 |
| NFR-004  | Documentation of length and resource limits   | All primitives                                  | Documentation requirement: if an implementation enforces stricter bounds than the conceptual limits in this profile (e.g., caps `L` or `|M|` to `2^31 − 1`), those limits MUST be explicitly documented in the public API, together with the error mode when limits are exceeded.                                                                 | Constraints.TurboSHAKE.M_length; Constraints.TurboSHAKE.L; Constraints.KangarooTwelve.M_length; Constraints.KangarooTwelve.C_length |
| NFR-005  | Independent, reentrant contexts               | All primitives with streaming/contextful APIs   | TurboSHAKE context objects and any additional contextful APIs (for example, KT128/KT256 or HopMAC contexts) MUST be independent: operations on one context MUST NOT mutate or depend on the internal state of another context except through explicit inputs/outputs. Distinct context instances MUST be safe to use concurrently from different threads (thread-compatible use), and the implementation MUST clearly document whether a single context is single-threaded-only, thread-compatible, or fully thread-safe for concurrent calls.        | API.TurboSHAKEContext; ErrorModel.ContextIndependence; RFC9861 |
| NFR-006  | Zeroization of secret material                | All primitives (when processing secrets)        | Where the host language, runtime, or commonly used cryptographic or system libraries provide a documented mechanism for securely wiping memory that holds secrets (e.g., `memset_s`, `explicit_bzero`, `SecureZeroMemory`, or an equivalent best-practice API), implementations SHOULD use such a mechanism to wipe secret data (keys, intermediate digests, and internal state that directly depends on secrets) when a context or key object is destroyed or reset, and SHOULD do so in a way that avoids obvious compiler/optimizer removal of the wipe. In environments where no such mechanism exists, implementations SHOULD either document this fact for the target/platform combination or use the best-known techniques available in that environment to reduce the lifetime of secret material in memory. Documentation requirement (informative): generated documentation should briefly state whether the implementation attempts explicit zeroization of secrets and what limitations, if any, apply on the target platform. | Constraints.HopMAC.Key_length; API.HopMAC128; API.HopMAC256; RFC9861 |
| NFR-007  | Cross-platform byte-level consistency         | All primitives                                  | Implementations MUST define all operations in terms of bytes and the FIPS 202 lane layout; outputs MUST be identical across 32-bit and 64-bit architectures and across little- and big-endian platforms. No optimization that exploits platform endianness MAY change observable outputs for any FR-covered behavior or test vector.                 | API.KP; RFC9861; FIPS202 |
| NFR-008  | RFC 9861 test suite coverage                  | TurboSHAKE128/256, KT128/256                    | A conformant implementation MUST include automated tests that cover all RFC 9861 test vectors referenced in FR-019–FR-022. Failing any of these tests MUST be treated as a non-conformant implementation.                                                                                                                                       | FR-019; FR-020; FR-021; FR-022; RFC9861 |
| NFR-009  | Mapping documentation from spec to API        | All primitives                                  | Documentation requirement: implementations MUST document how the named primitives and parameters in this profile map to concrete functions, methods, and types in the target language (e.g., which function implements KT256, what type represents a TurboSHAKE context, and how `D`, `M`, `C`, and `L` are passed).                              | API.TurboSHAKE128; API.TurboSHAKE256; API.KT128; API.KT256; API.HopMAC128; API.HopMAC256; RFC9861 |
| NFR-010  | No reliance on undefined behavior             | All primitives                                  | Implementations MUST avoid invoking undefined or implementation-defined behavior in the host language (e.g., signed integer overflow) in any code path that influences observable outputs or error behavior for these primitives. Behavior MUST remain well defined for all inputs that satisfy the FR preconditions.                                | ErrorModel.ResultSemantics |

## Test Vectors & Conformance

RFC 9861 defines test vectors for TurboSHAKE and KangarooTwelve using the pattern `ptn(n)`.[RFC9861] The machine-readable index of those RFC 9861 test-vector families, together with the canonical local HopMAC test vectors defined in this section, is bundled in `conformance.yaml` (the conformance and test-vector companion to the ProfileSchema bundle in `profile-core.yaml`). Tools and CI systems SHOULD consume `conformance.yaml` as the primary source of test-vector metadata, and treat this section’s prose and hex dumps as an explanatory view over that bundle.

### 1. `ptn(n)` Definition

* `ptn(n)` is defined as the first `n` bytes of the infinite pattern:

  * `00, 01, 02, …, F9, FA, 00, 01, …` (incrementing modulo 0xFB).[RFC9861]

Algorithmically:

* For integer `n ≥ 0`, define `ptn(n)` as a byte string of length `n` where `ptn(n)[i] = (i mod 0xFB)` for `i = 0..n−1`.

Any conformant implementation MUST reproduce `ptn(n)` exactly.

### 2. Local HopMAC Test Vectors

In addition to the RFC 9861 TurboSHAKE and KT test vectors referenced in FR-019–FR-022, this profile defines **canonical local HopMAC test vectors**. These vectors are intended to exercise the HopMAC128/256 constructions directly and to provide stable, profile-wide reference points beyond any project-specific tests.

Implementations that claim HopMAC128/256 conformance SHOULD include automated tests that verify their computed tags for these vectors **exactly** match the reference tags below. Implementations MAY define additional local HopMAC test vectors, but such additional vectors are outside the scope of this profile and do not affect FR-023.

- **HopMAC128 canonical local vector**

  - `Key = ptn(16)`  
    – bytes: `00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F`
  - `M = ptn(32)`  
    – bytes:  
      `00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F`  
      `10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F`
  - `C = "HopMAC128 local test"` (UTF-8)
  - `L = 32`
  - Expected `tag` (32 bytes, hex):

    `62 BA AD 51 6C 2A 3B 39 25 32 F8 E7 BE ED 74 32`  
    `8B CD 07 82 40 9D B7 EE B7 72 31 5E 83 DE 40 51`

- **HopMAC256 canonical local vector**

  - `Key = ptn(32)`  
    – bytes:  
      `00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F`  
      `10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F`
  - `M = ptn(64)`  
    – bytes:  
      `00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F`  
      `10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F`  
      `20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F`  
      `30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F`
  - `C = "HopMAC256 local test"` (UTF-8)
  - `L = 64`
  - Expected `tag` (64 bytes, hex):

    `8F 56 1D 5D E2 AB 76 7A D4 6E 95 87 14 CF 15 CF`  
    `99 89 53 EF AF 57 48 A1 DA 5B 2B E9 1E 08 5B 49`  
    `BB A3 9E 23 23 F1 B7 AA B6 A9 83 4D AB 7D B8 7D`  
    `01 7A FD E6 BC CC A0 57 63 BF 9B AD F1 FB B8 56`

*Non-normative note on RFC 9861 test vectors.* The RFC 9861 TurboSHAKE128/256 and KT128/256 test vectors remain normatively defined by RFC 9861 itself; to avoid duplication and drift, this profile does not repeat the full hex outputs. Instead, the `ExternalTestSuites` and `ExternalTestVectors` blocks in the ProfileSchema provide a machine-readable index of test-vector families, inputs, and parameter patterns that agents and conformance harnesses can consume directly. Concrete expected outputs for those vectors MUST be taken from RFC 9861 (or from project-specific fixtures that are mechanically derived from it); any discrepancy between the indexed vectors in this profile and RFC 9861 is a defect in this profile and does not change the canonical RFC test values.

### 3. Conformance Criteria

This profile distinguishes two related notions of conformance:

- **Schema-level conformance**, which applies to tools, pipelines, and repositories that
  parse, validate, or distribute ProfileSchema artifacts. Schema-level conformance is
  about the internal consistency of the specification artifact itself and is enforced
  via the ProfileSchema invariants and CC-4.
- **Behavioral profile conformance**, which applies to implementations of KP,
  TurboSHAKE128/256, TurboSHAKEContext, KT128/256, and HopMAC128/256. Behavioral
  conformance is defined by satisfying all applicable FR/NFR entries and passing the
  required test vectors for a specific profile version; it does not depend on whether
  the implementation’s own toolchain executed the ProfileSchema invariants, only that
  the behavior matches a structurally valid ProfileSchema artifact.
The canonical machine-readable set of conformance criteria (CC‑1…CC‑4) is defined in the `ConformanceCriteria` section of the ProfileSchema bundle in `profile-core.yaml`. The text above summarizes their meaning: CC‑1 and CC‑2 require FR/NFR compliance for all claimed primitives, CC‑3 requires coverage of the RFC 9861 and local HopMAC test vectors, and CC‑4 ties schema-level conformance to successful evaluation of `ProfileSchemaInvariants`/`ProfileSchemaInvariantsRole` for any ProfileSchema artifact that is treated as canonical. Conformance tooling MUST use the `ConformanceCriteria` entries in `profile-core.yaml` as authoritative for machine-readable conformance rules.

---

### 3. Conformance Profiles

Named conformance bundles for common implementation scopes:

* **Profile T (TurboSHAKE-only)**  
  * Claims: TurboSHAKE128 and/or TurboSHAKE256 only.  
  * Intended FR coverage: TurboSHAKE-specific FRs and shared FRs (see matrix below).  
* **Profile TK (TurboSHAKE + KangarooTwelve)**  
  * Claims: TurboSHAKE128/256 and KT128/256.  
  * Intended FR coverage: TurboSHAKE and KT-specific FRs and shared FRs.  
* **Profile TKH (TurboSHAKE + KangarooTwelve + HopMAC)**  
  * Claims: TurboSHAKE128/256, KT128/256, HopMAC128/256.  
  * Intended FR coverage: all FRs applicable to TurboSHAKE, KT, and HopMAC.

### 4. FR Coverage by Conformance Profile (Non-Normative)

This matrix restates, in compact form, which FRs must be satisfied for each named conformance profile. It is descriptive only; the authoritative requirements remain the FR-xxx definitions above and the profile descriptions in this section.

| FR ID  | Applies to                     | Profile T | Profile TK | Profile TKH |
|--------|--------------------------------|-----------|------------|-------------|
| FR-001 | Keccak-p[1600,12] permutation  | ✓         | ✓          | ✓           |
| FR-002 | TurboSHAKE one-shot interface  | ✓         | ✓          | ✓           |
| FR-003 | TurboSHAKE domain byte         | ✓         | ✓          | ✓           |
| FR-004 | TurboSHAKE output length       | ✓         | ✓          | ✓           |
| FR-005 | TurboSHAKE message lengths     | ✓         | ✓          | ✓           |
| FR-006 | TurboSHAKE sponge algorithm    | ✓         | ✓          | ✓           |
| FR-007 | TurboSHAKE XOF prefix          | ✓         | ✓          | ✓           |
| FR-008 | TurboSHAKE streaming (optional)| (✓)\*     | (✓)\*      | (✓)\*        |
| FR-009 | `length_encode(x)` domain      |           | ✓          | ✓           |
| FR-010 | Customization / node counts    |           | ✓          | ✓           |
| FR-011 | K12 base string & chunking     |           | ✓          | ✓           |
| FR-012 | KT128 single-node              |           | ✓          | ✓           |
| FR-013 | KT128 tree case                |           | ✓          | ✓           |
| FR-014 | KT256 behavior                 |           | ✓          | ✓           |
| FR-015 | HopMAC128 interface            |           |            | ✓           |
| FR-016 | HopMAC256 interface            |           |            | ✓           |
| FR-017 | HopMAC behavior                |           |            | ✓           |
| FR-018 | Pattern `ptn(n)` definition    | ✓         | ✓          | ✓           |
| FR-019 | TurboSHAKE128 test vectors     | ✓         | ✓          | ✓           |
| FR-020 | TurboSHAKE256 test vectors     | ✓         | ✓          | ✓           |
| FR-021 | KT128 test vectors             |           | ✓          | ✓           |
| FR-022 | KT256 test vectors             |           | ✓          | ✓           |
| FR-023 | Local HopMAC test vectors      |           |            | ✓           |
| FR-024 | No partial outputs on error    | ✓         | ✓          | ✓           |

\* FR-008 applies only if a TurboSHAKE streaming API is implemented.

### 5. NFR Coverage by Conformance Profile (Non-Normative)

All NFRs are cross-cutting; for each profile, every applicable NFR MUST be satisfied in addition to the FRs above. The table below summarizes this:

| NFR ID  | Applies to                             | Profile T | Profile TK | Profile TKH |
|---------|----------------------------------------|-----------|------------|-------------|
| NFR-001 | Deterministic, side-effect-free behavior | ✓       | ✓          | ✓           |
| NFR-002 | Constant-time handling of secret data  | ✓         | ✓          | ✓           |
| NFR-003 | Deterministic error semantics          | ✓         | ✓          | ✓           |
| NFR-004 | Documentation of limits                | ✓         | ✓          | ✓           |
| NFR-005 | Independent, reentrant contexts        | ✓         | ✓          | ✓           |
| NFR-006 | Zeroization of secret material         | ✓         | ✓          | ✓           |
| NFR-007 | Cross-platform byte-level consistency  | ✓         | ✓          | ✓           |
| NFR-008 | RFC 9861 test suite coverage           | ✓         | ✓          | ✓           |
| NFR-009 | Mapping documentation from spec to API | ✓         | ✓          | ✓           |
| NFR-010 | No reliance on undefined behavior      | ✓         | ✓          | ✓           |

An implementation MAY declare conformance to any subset of these profiles; in all cases, the general criteria in “Conformance Criteria” and the FR/NFR definitions remain authoritative.

---
## Part II – Non-Normative Commentary

Part II contains only the minimal non-normative commentary needed to support implementation planning and conformance from this profile. Its purpose is to help agents map the normative core (Constraints, API Contracts, algorithms, Error Model, FR/NFR tables) into concrete implementation plans, not to provide general background, tutorials, or security essays. Commentary that does not materially influence how an agent structures code, enforces constraints, or wires tests MUST NOT be added here; such material belongs in separate design or security documents.

### Customization String `C` – Usage Checklist (Non-Normative)

The customization string `C` is a powerful domain-separation tool for KT128/KT256 (and therefore HopMAC). The core profile treats `C` as an opaque byte string, but protocol and API designers should apply the following usage patterns:

- Treat `C` as a structured, textual identifier for the *function of the call*, not as a secret.
- Include, at minimum:
  - an application or library identifier (e.g., `"com.example.payment-service"`),
  - a protocol or schema version (e.g., `"v1"`), and
  - a role or purpose label (e.g., `"HopMAC-MAC"`, `"K12-hash"`, `"K12-KDF"`).
- Use distinct `C` values for distinct purposes, even within the same application (for example, do not reuse the same `C` for both hashing and MAC, or for different keys or KDF stages).
- Do not reuse the same `C` across unrelated protocols or products; if two components are maintained separately, they should coordinate on unique prefixes or namespaces in `C`.
- Prefer stable encodings (for example, UTF-8 text with a fixed separator convention) over ad-hoc binary blobs, so that `C` values can be documented and audited.
- Do not place high-entropy secrets into `C`; secrets belong in `M` or in higher-level key-derivation inputs, while `C` is for labeling the function and context.

These guidelines do not change the normative definition of `C` in this profile; they simply reduce the risk of accidental domain collisions when KT and HopMAC are used in larger systems.

### Implementation Checklist (Non-Normative)

This non-normative checklist restates FR/NFR obligations as actionable steps. It is a derived planning artifact: agents must not treat this YAML as an independent source of requirements or introduce new numeric bounds, reserved-value sets, or algorithm variants here. Every step’s actual normative force comes only from the referenced FR/NFR entries, API Contracts, algorithms, Error Model, and `Constraints` schema.

The canonical machine-readable `ImplementationChecklist` (STEP‑1…STEP‑11) is defined in the ProfileSchema bundle in `profile-core.yaml` and is derived mechanically from the FR/NFR tables and the behavioral core. Tools and agents should treat that checklist as a planning aid only, using the entries in `profile-core.yaml` when they need a structured list of steps, and MUST continue to take all enforceable requirements from FR/NFR entries, API Contracts, algorithms, Error Model, and the `Constraints` schema rather than from the checklist itself.

### Appendix A: Using This Spec with AI/LLM Agents (Non-Normative)

If you are an AI agent (LLM) or other code-generation tool tasked with implementing these primitives, you should primarily rely on the guidance already given in:

- **“How an Agent Uses This Specification”** (agent workflow and canonical sources),
- the **LLM Implementation Contract** (how to interpret the ProfileSchema and behavioral core), and
- the **Functional/Non-Functional Requirements** tables together with the **Implementation Checklist** (what to implement and test).

This appendix is intentionally brief to avoid duplicating that guidance; agents should treat those sections as the single, well-signposted sources for agent-focused workflow and planning, and use this appendix only as a reminder to consult them.

This concludes the profiled, rationale-annotated specification suitable as a primary artifact for spec-driven, LLM-assisted implementations of TurboSHAKE, KangarooTwelve, and HopMAC as defined in RFC 9861.

[RFC9861]: https://datatracker.ietf.org/doc/rfc9861/ "RFC 9861 - KangarooTwelve and TurboSHAKE"
[KeccakTS]: https://keccak.team/turboshake.html "TurboSHAKE technical details"
[KeccakRFC9861]: https://keccak.team/2025/rfc9861.html "Keccak team commentary on RFC 9861"
[FIPS202]: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf "FIPS 202 - SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions"
[K12Draft]: https://datatracker.ietf.org/doc/draft-irtf-cfrg-kangarootwelve/10/ "draft-irtf-cfrg-kangarootwelve-10"
